use anchor_lang::prelude::*;
use anchor_lang::InstructionData;
use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
use raceswap::instruction::ExecuteRaceswap;
use raceswap::{ExecuteRaceswapParams, SerializedInstruction};

fn sample_payload() -> SerializedInstruction {
    SerializedInstruction {
        accounts_len: 4,
        data: vec![1, 2, 3, 4, 5, 6],
        is_writable: vec![true, true, false, true],
        is_signer: vec![false, false, false, false],
    }
}

fn sample_reflection_payload() -> SerializedInstruction {
    SerializedInstruction {
        accounts_len: 3,
        data: vec![9, 8, 7, 6],
        is_writable: vec![true, false, true],
        is_signer: vec![false, false, false],
    }
}

fn sample_params() -> ExecuteRaceswapParams {
    ExecuteRaceswapParams {
        input_mint: pubkey!("So11111111111111111111111111111111111111112"),
        main_output_mint: pubkey!("Es9vMFrzaCERZ5Yj5BLtVPRpgd81pQAb9Y8p9RV4bG9x"),
        reflection_mint: pubkey!("7vfCXTUXF1VbzzcQq87dyGzvHGQB1b9DsqPQbEEkU3wP"),
        total_input_amount: 123_456_789,
        min_main_out: 11_111_111,
        min_reflection_out: 22_222_222,
        disable_reflection: false,
        main_leg: Some(sample_payload()),
        reflection_leg: Some(sample_reflection_payload()),
    }
}

fn to_hex(data: &[u8]) -> String {
    data.iter().map(|b| format!("{:02x}", b)).collect()
}

#[test]
fn print_anchor_encoder_bytes() {
    let params = sample_params();
    let ix = ExecuteRaceswap { params };
    let data = ix.data();
    println!("Anchor encoder bytes: {}", to_hex(&data));
    println!(
        "Anchor encoder base64: {}",
        BASE64_STANDARD.encode(&data)
    );
    assert!(!data.is_empty());
}
