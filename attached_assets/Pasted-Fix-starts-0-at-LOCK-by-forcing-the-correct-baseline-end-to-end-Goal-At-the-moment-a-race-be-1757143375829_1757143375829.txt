Fix “% starts > 0 at LOCK” by forcing the correct baseline end-to-end

Goal: At the moment a race becomes LOCKED, every runner must display 0.0%. All subsequent % changes must be computed as (currPriceUsd - initialPriceUsd) / initialPriceUsd using the same quote (USD) and the same price source. Remove any fallback to change24h, openingPrice, or “creation-time price”.

0) Shared helper (server + client)

Create a tiny, single-definition function and reuse it everywhere:

export function pctGain(initial: number | undefined | null, current: number | undefined | null): number {
  const i = Number(initial ?? 0);
  const c = Number(current ?? 0);
  if (!(i > 0 && isFinite(i) && c > 0 && isFinite(c))) return 0;
  return (c - i) / i;
}

1) Price source must be consistent (USD)

server/prices.ts (or your price util)

Ensure we always return USD prices and only USD:

export type LivePriceByMint = Record<string /*mint*/, number /*priceUsd*/>;

export async function getLivePricesForRunners(runners: Runner[]): Promise<LivePriceByMint> {
  // Use one provider only. Map strictly by mint (NOT symbol/name).
  // Return { [mint]: priceUsdNumber }
}


If your provider sometimes returns priceNative or SOL-quoted values, do not use them. Only return priceUsd.

2) LOCK flow: snapshot, persist, then broadcast (no race condition)

server/admin.ts (or wherever you lock a race)

// 1) load + validate
const race = await db.getRace(raceId);
if (race.status !== 'OPEN') throw new Error('Only OPEN can be LOCKED');

// 2) snapshot (await!)
const live = await getLivePricesForRunners(race.runners);
race.runners = race.runners.map(r => ({
  ...r,
  initialPriceUsd: Number(live[r.mint] ?? 0),
  initialPriceTs: Date.now(),
}));

// guard: if any initialPriceUsd <= 0, retry once
if (race.runners.some(r => !(r.initialPriceUsd > 0))) {
  const retry = await getLivePricesForRunners(race.runners);
  race.runners = race.runners.map(r => ({
    ...r,
    initialPriceUsd: r.initialPriceUsd > 0 ? r.initialPriceUsd : Number(retry[r.mint] ?? 0),
  }));
}

// 3) flip status + timestamps
race.status = 'LOCKED';
race.lockedTs = Date.now();

// 4) persist before notifying
await db.saveRace(race);

// 5) re-read and then broadcast
const fresh = await db.getRace(raceId);
await broadcaster.emitRaceUpdate(fresh);


Delete any code that sets winnerIndex at lock.

Delete/stop any code that still writes initialPrice at race creation.

3) Server poller/settlement must always use the locked baseline

server/sse.ts & server/settlement.ts

Replace any usage of openingPrice, createdPrice, change24h with runner.initialPriceUsd.

When computing leaders or settling:

const curr = live[r.mint];              // priceUsd now
const base = r.initialPriceUsd;         // USD baseline at lock
const gain = pctGain(base, curr);       // -> number (e.g., 0.132)


Never mutate initialPriceUsd after LOCK.

4) Frontend must never fall back to 24h change

web/src/store/selectors.ts (or wherever you compute leader)

Find your leader selector; remove any fallback like:

runner.percent24h || runner.delta || runner.change

runner.trendingDelta

Force it to use the server baseline:

const latestUsd = runner.latestPriceUsd ?? runner.priceUsd; // whatever your feed stores now
const baseUsd   = runner.initialPriceUsd;
const pct       = pctGain(baseUsd, latestUsd);


Race card component (e.g., RaceCard*.tsx)

On transition OPEN → LOCKED, set a client-side baseline map keyed by mint to initialPriceUsd (from the race payload that includes initialPriceTs).

While waiting for the first post-lock payload that contains initialPriceUsd, display 0.0% instead of computing off anything else.

useEffect(() => {
  if (prevStatus === 'OPEN' && race.status === 'LOCKED') {
    setBaselineByMint(Object.fromEntries(race.runners.map(r => [r.mint, r.initialPriceUsd ?? 0])));
  }
}, [race.status, race.runners]);


Replace any display of runner.change24h, runner.priceChangePct, etc., in the “Current Leader” UI with the computed pct above.

5) Kill hidden fallbacks & caches

Grep the repo for these terms and remove/fix references in both server and client:

change24h, priceChangePercent, openingPrice, createdPrice, percent24h, trendDelta

If you keep a price cache on the server, ensure it does not overwrite initialPriceUsd for locked races.

6) Add quick assertions & logs (temporary)

On lock, log baseline:

[LOCK] race=<id> baselines: {<mint>: <priceUsd>, ...}


On the first price tick after lock, log deltas computed against baseline; they must all be 0.000… (± small float noise):

[TICK] race=<id> deltas: {<mint>: <pct*100>% , ...}


Add a server assertion (temp): if any delta’s absolute value on the first tick is > 0.2%, log BASELINE_MISMATCH with the runner and the fields the UI might be using (e.g., it’s still reading change24h).

7) Settlement unchanged (still baseline vs final)

Just confirm you’re using initialPriceUsd at settle time, same provider.

8) Minimal test

Create a test race with startMinutesFromNow = 0.5 (30s).

When it flips to LOCKED, “Current Leader” must show 0.0%.

After the next tick, numbers begin changing from 0.0.

If any runner shows a non-zero immediately at lock, print the BASELINE_MISMATCH log and fail the test.

Deliverables

Files changed summary + a short log snippet showing:
OPEN → LOCKED (all 0.0%) → first poll (still ~0.0%) → later polls (non-zero).

Confirmed removal of all fallbacks to 24h change or creation-time price.

Grep output lines demonstrating change24h/openingPrice/createdPrice are no longer referenced in race UI/logic.