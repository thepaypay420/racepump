You are Replit’s AI Agent. Create a **fully functional**, end-to-end Solana dApp called **Pump Racers** that I can run on Replit TODAY (no placeholders, no mock data). It’s a parimutuel race betting game where users bet our SPL token **$RACE** on which **top market-cap Pump.fun tokens** will win a short animated race. The system must run entirely on **devnet** with **real on-chain SPL transfers**, **verifiable randomness**, and a production-style front end. If any required env var is missing, the app must fail with a clear error message (not fallback to mocks).

────────────────────────────────────────────────────────────────────────

CORE FUNCTIONALITY (ALL REAL)
1) Wallets & Token
   - Connect Phantom/Solflare via wallet-adapter.
   - Show SOL and **$RACE** balances (SPL, 9 decimals).
   - Provide a **devnet faucet** endpoint to airdrop small amounts of $RACE for testing.
   - All bets and payouts are SPL token transfers of $RACE.

2) Runners (Top Pump.fun Tokens) — REAL DATA
   - Server endpoint `GET /runners/top?limit=12` returns **live** top Pump.fun tokens with: `{mint, symbol, name, logoURI, marketCap}`.
   - Primary source: **Bitquery Pump.fun API** (GraphQL) to list tokens + market caps.
   - Fallback: **Birdeye API** to enrich market caps/logos by mint.
   - Cache results for 20 seconds only. If both providers fail, return HTTP 502 (do NOT serve mock data).

3) Bets & Escrow (Custodial MVP)
   - Users place bets by **transferring $RACE** from their wallet to an **escrow ATA** owned by the server keypair (devnet).
   - Client prepares a normal SPL transfer to the escrow ATA and submits it; then POST `/bet` with `{raceId, runnerIdx, amount, fromPubkey, txSig}`.
   - Server **confirms** the transaction on-chain and verifies: mint == RACE_MINT, recipient == escrow ATA, amount matches request, and fromPubkey matches signer. Only then record the bet in DB.
   - Lock betting at `startTs` (scheduler + manual admin lock).

4) Provably-Fair Randomness (Verifiable, No Placeholders)
   - RNG supports two **fully implemented** modes (choose via env; both must exist):
     a) `RNG_MODE=drand`: Use drand HTTP API (mainnet fastnet). Verify the round signature/chain hash on the server using official drand libs. Compute `winnerIndex = uint32(keccak256(drand_randomness || raceId)) % N`. Store round, randomness, signature, and derived winner in DB.
     b) `RNG_MODE=chainlink-evm`: Use **Chainlink VRF v2.5** on a supported **EVM testnet**. Provide a tiny Node module that:
        - Deploys or attaches to a minimal VRF consumer contract (compiled via hardhat/ethers in a subfolder) with subscription ID + coordinator + keyHash from env.
        - Requests randomness and waits for fulfillment; reads the random word from the emitted event; verifies block confirmations.
        - Returns the random word to the server process which derives `winnerIndex` as above.
        - NOTE: We are NOT bridging on-chain to Solana in this MVP; the server consumes Chainlink VRF randomness and settles SPL payouts on Solana (documented clearly in README).
   - If `RNG_MODE=chainlink-evm` env vars are missing, the server must refuse to start in that mode; users can set `RNG_MODE=drand` to run.

5) Settlement (Parimutuel)
   - Pot `P = Σ all bets`.
   - Rake = 3% (configurable via env `RAKE_BPS`, max 500 bps). Split: **2% team treasury**, **1% jackpot rollover** (if 3% rake).
   - PrizePool `R = P * (1 - rake) + (jackpotFlag ? jackpotBalance : 0)`.
   - For winner side total `W`, each bet `b` pays `R * (b / W)`, rounded **down** to 9 decimals.
   - Jackpot: accumulate **1% of every pot**, add it automatically on every **20th race**, then reset to 0.
   - POST `/claim` with `{raceId, wallet}` aggregates a wallet’s winnings and performs **SPL token transfers from escrow** to the wallet ATA; return tx sig(s). Record claims in DB.

6) Admin (Secure)
   - `/admin/race/create` `{startTs, rakeBps, jackpotFlag, limit}` → snapshot N runners from `/runners/top`, freeze into DB as indexes 0..N-1, set status OPEN.
   - `/admin/race/lock` → flip to LOCKED, trigger RNG (drand or Chainlink VRF) and compute `winnerIndex`.
   - `/admin/race/cancel` (OPEN only) → refund **principal only** back to each bettor (SPL transfers).
   - `/admin/faucet` `{toPubkey, amount}` → airdrop small $RACE amounts for testing (rate-limit).
   - Protect admin routes with a **static bearer secret** env `ADMIN_TOKEN` (reject if missing/invalid). Log all admin actions.

7) Front End (React + Vite + Tailwind + TS)
   - **WalletBar**: connect wallet, show SOL + $RACE, “Get test $RACE” (calls faucet).
   - **Lobby**: list OPEN/LOCKED/SETTLED races, runner cards with **implied odds** (recalculated from server totals).
   - **RaceDetail**: grid of runners (logo/symbol/marketCap), bet slip (runner + amount), countdown to `startTs`, your active bets, live implied odds.
   - **LiveRace**: 15–20s Canvas animation (60fps). When server publishes the settled winner (SSE or websocket), animate that lane breaking the tape. Seed the animation PRNG with `keccak256(raceId || rngSeed)` so replays are deterministic.
   - **Results**: show winner, your winnings (if any), **Claim** button.
   - **Admin**: form to create, lock, cancel races (requires entering `ADMIN_TOKEN` once per session; store in memory only).

8) UX/Visual (PopShot-style)
   - Black background; neon accents; bold/clean outlines; slight grain on panels; big readable numbers; snappy transitions.
   - Implied odds displayed as “payout per 1,000 $RACE”.
   - Shareable win poster: GET `/share/race/:id/win/:wallet` renders a server-side canvas image (or node-canvas) with winner + payout and returns PNG.

9) Security / Correctness
   - All token math in `decimal.js` (no FP drift).
   - Validate all inputs with `zod`.
   - Confirm every bet’s on-chain transfer before recording.
   - Rate-limit faucet and admin endpoints; simple IP throttle.
   - CORS restricted to same origin; configurable allowlist via env.
   - Clear, actionable errors for missing envs/APIs.

────────────────────────────────────────────────────────────────────────

TECH STACK & PROJECT STRUCTURE
- Node 18+ (pin in `replit.nix` if needed), TypeScript everywhere.
- Frontend: React, Vite, Tailwind, wallet-adapter, Zustand (state), Decimal.js, Zod.
- Server: Express, Axios, better-sqlite3, Pino, Node-Cache, @solana/web3.js, @solana/spl-token, bs58, @drand/client + @drand/chain, (optional) ethers/hardhat for Chainlink VRF mode.
- Realtime: SSE or `ws` websockets for race status updates.

Create this file tree and implement code now:
root/
package.json
.replit # run = "npm run dev"
replit.nix # nodejs >= 18 if necessary
vite.config.ts
tailwind.config.ts
postcss.config.cjs
public/
logo.svg
server/
index.ts # app bootstrap, routes mount, health, CORS, pino
db.ts # better-sqlite3 schema + helpers
runners.ts # Bitquery/Birdeye fetch + cache + /runners/top
bets.ts # bet intake, on-chain tx verification
settlement.ts # rake, jackpot, payout calculation & SPL transfers
rng.ts # drand verify + Chainlink VRF (EVM) module
admin.ts # create/lock/cancel/faucet endpoints, auth
sse.ts # optional SSE broadcaster for race events
solana.ts # connection, keypair, ATAs, helpers
chainlink/
hardhat.config.ts # ONLY if RNG_MODE=chainlink-evm
contracts/VRFConsumer.sol
scripts/requestAndRead.ts
src/
main.tsx
App.tsx
lib/
api.ts # REST client, SSE/ws hookup
solana.ts # wallet adapter setup
math.ts # decimal helpers
store.ts # zustand store
pages/
Lobby.tsx
RaceDetail.tsx
LiveRace.tsx
Results.tsx
Admin.tsx
components/
WalletBar.tsx
RaceCard.tsx
RunnerGrid.tsx
BetSlip.tsx
OddsBar.tsx
Countdown.tsx
styles/
tailwind.css

java
Copy code

────────────────────────────────────────────────────────────────────────

ENVIRONMENT VARIABLES (Replit Secrets) — REQUIRED
Solana + Token
RPC_URL=https://api.devnet.solana.com
ESCROW_PRIVATE_KEY=<base58-encoded devnet secret key> # server signer holds escrow + treasury + jackpot
RACE_MINT=<devnet mint address> # if absent, server MUST create a mint/ATA at startup and persist value in sqlite

Admin + CORS
ADMIN_TOKEN=<random-long-secret> # required to call admin routes
CORS_ALLOWLIST=<comma-separated origins> # optional; defaults to current origin

Data providers (no mocks!)
BITQUERY_API_KEY=<key> # used first for Pump.fun list + caps
BIRDEYE_API_KEY=<key> # used as fallback for caps/logos

RNG
RNG_MODE=drand # or chainlink-evm
DRAND_CHAIN_URL=https://api.drand.sh # mainnet fastnet endpoint

Chainlink VRF (only if RNG_MODE=chainlink-evm; app must fail if these missing when mode selected)
ETH_RPC_URL=<evm testnet rpc>
CHAINLINK_VRF_SUB_ID=<subscription id>
VRF_COORDINATOR=<address>
VRF_KEY_HASH=<keyHash>
CONSUMER_ADDRESS=<deployed consumer addr or leave blank to auto-deploy>

bash
Copy code

────────────────────────────────────────────────────────────────────────

IMPLEMENTATION CHECKLIST (Build Now)
1) package.json
   - deps for frontend + server (see stacks above)
   - scripts:
     {
       "dev": "concurrently \"vite\" \"ts-node --transpile-only server/index.ts\"",
       "build": "vite build",
       "preview": "vite preview"
     }

2) server/db.ts
   - better-sqlite3; create tables on first run:
     races(id TEXT PK, startTs INTEGER, status TEXT, rakeBps INTEGER, jackpotFlag INTEGER, jackpotAdded INTEGER DEFAULT 0, winnerIndex INTEGER, drandRound INTEGER, drandRandomness TEXT, drandSignature TEXT)
     race_runners(raceId TEXT, idx INTEGER, mint TEXT, symbol TEXT, name TEXT, logo TEXT, marketCap REAL, PRIMARY KEY(raceId, idx))
     bets(id TEXT PK, raceId TEXT, wallet TEXT, runnerIdx INTEGER, amount TEXT, sig TEXT, ts INTEGER)
     claims(id TEXT PK, raceId TEXT, wallet TEXT, amount TEXT, sig TEXT, ts INTEGER)
     treasury(state TEXT PK, jackpotBalance TEXT DEFAULT '0', raceMint TEXT)

3) server/solana.ts
   - connect to devnet, load ESCROW_PRIVATE_KEY.
   - ensure mint + ATAs exist (escrow, team treasury if separate).
   - helpers: getAta(mint, owner), sendSpl(fromKP, toPubkey, mint, amount).

4) server/runners.ts
   - `getTopPumpfun(limit)` → Bitquery GraphQL query for Pump.fun tokens + marketCaps; on failure, Birdeye as fallback.
   - 20s NodeCache TTL.
   - `GET /runners/top?limit=12` → returns array; if both providers fail → 502.

5) server/index.ts
   - Express app with JSON, CORS (allowlist), pino logs.
   - Mount routes: /health, /runners/top, /bet, /claim, /admin/*, SSE (/events).
   - On boot: if !RACE_MINT, **create mint** (9 decimals), create escrow ATA, persist RACE_MINT in sqlite `treasury` row.

6) server/bets.ts
   - `POST /bet`: zod-validate body; confirm txSig via RPC; parse token transfer (recipient == escrow ATA, mint == RACE_MINT, amount matches); insert bet; return updated totals + implied odds.

7) server/admin.ts
   - Bearer `Authorization: Bearer ${ADMIN_TOKEN}` required.
   - `POST /admin/race/create {startTs, rakeBps, jackpotFlag, limit}`: fetch top runners, write race + race_runners (OPEN).
   - Background scheduler checks races; at startTs call `/admin/race/lock`.
   - `POST /admin/race/lock {raceId}`: set LOCKED, call RNG (rng.pickWinner), compute winnerIndex, emit SSE `race/settled`.
   - `POST /admin/race/cancel {raceId}`: refund principal by SPL transfers; set CANCELLED.
   - `POST /admin/faucet {toPubkey, amount}`: send small $RACE (rate-limit).

8) server/rng.ts
   - drand mode: fetch latest round JSON, verify signature/chain hash with @drand/chain; derive seed; winnerIndex = keccak(seed||raceId) % N; store drand fields.
   - chainlink-evm mode: if CONSUMER_ADDRESS missing, compile & deploy VRFConsumer.sol via ethers; request randomness with sub id, wait for fulfillment event; read random word; compute winnerIndex; store tx hash + word.

9) server/settlement.ts
   - Functions to compute totals using Decimal.js.
   - `payoutMap = {wallet: Decimal}` for winners.
   - Claim endpoint: transfer SPL amounts from escrow ATA to claimant ATA(s); record claims.

10) server/sse.ts (or ws)
   - Basic event stream that broadcasts `race/created`, `race/locked`, `race/settled`.

11) Frontend
   - Tailwind setup; dark theme styles.
   - Wallet adapter providers; show balances.
   - Lobby: fetch races list, implied odds (server can expose `/races` aggregation).
   - RaceDetail: show runners + logos + marketCaps; bet slip posts `/bet` after user submits blockchain tx and returns txSig; live countdown.
   - LiveRace: start animation on lock; on settled event, animate winning lane.
   - Results: display winner + your expected payout; call `/claim`.
   - Admin: header field to paste ADMIN_TOKEN; forms to create/lock/cancel.

12) README.md (root)
   - One-page ops guide: required envs; how to create RACE mint on first run; how to switch RNG mode; how to set Chainlink VRF values; warnings (devnet only, custodial escrow).

────────────────────────────────────────────────────────────────────────

RUN COMMAND
- Configure `.replit` to run: `npm run dev`
- If Node version mismatch, add `replit.nix` for Node 18+.

DELIVERABLE
- Generate ALL code and configs now, ready to run with `npm install && npm run dev`.
- No placeholder logic and no mock runners.
- Clear errors if any env or API key is missing.