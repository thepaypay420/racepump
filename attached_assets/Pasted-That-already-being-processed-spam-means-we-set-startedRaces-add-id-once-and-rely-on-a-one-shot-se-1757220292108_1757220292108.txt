That “already being processed” spam means we set startedRaces.add(id) once and rely on a one-shot setTimeout to flip to LOCKED later. If that timeout is missed (dev server reload, transient error, container sleep), the 5s loop keeps seeing the race, but skips doing anything because startedRaces is set—so it never locks/settles.

The fix (deterministic, watchdog-style)

Make the 5-second loop enforce state transitions from timestamps, ignoring startedRaces for overdue steps:

If a race is OPEN and now >= startTs + OPEN_MS ⇒ force lock it immediately (don’t consult startedRaces).

If a race is LOCKED/IN_PROGRESS and now >= lockedTs + PROGRESS_MS ⇒ settle it immediately.

Keep startedRaces only to avoid scheduling duplicate timers; but do not let it block the watchdog.

Below are surgical patches—no file overwrite.

1) server/sse.ts — add a watchdog pass inside startCountdownUpdater()

Place this inside the 5-second interval, after the existing “raceToStart” block:

// --- WATCHDOG: deterministic state enforcement (ignores startedRaces) ---
const OPEN_MS = Number(process.env.OPEN_WINDOW_MINUTES ?? '30') * 60 * 1000;
const PROGRESS_MS = Number(process.env.PROGRESS_WINDOW_MINUTES ?? '30') * 60 * 1000;
const allRaces = sqliteDb.getRaces();
const nowMs = Date.now();

for (const r of allRaces) {
  try {
    // If it's still OPEN but past the betting window, force lock
    if (r.status === 'OPEN' && nowMs >= r.startTs + OPEN_MS) {
      console.log(`⛏️ Watchdog: force-locking overdue race ${r.id}`);
      await forceRaceToLocked(r.id); // DO NOT check startedRaces here
      continue;
    }

    // If it's LOCKED/IN_PROGRESS and the progress window elapsed, force settle
    if ((r.status === 'LOCKED' || r.status === 'IN_PROGRESS') && r.lockedTs) {
      if (nowMs >= Number(r.lockedTs) + PROGRESS_MS) {
        console.log(`⛏️ Watchdog: force-settling overdue race ${r.id}`);
        await settleRace(r.id, Number(r.lockedTs)); // DO NOT check startedRaces here
      }
    }
  } catch (e) {
    console.error(`Watchdog transition failed for ${r.id}:`, e);
  }
}


This removes the “stuck forever” failure mode: even if the initial setTimeout never fires, the watchdog will progress the race on the next tick.

2) Keep your timer chain, but don’t let it gate the watchdog

Leave your current calls to startRaceProgression(...) as they are. They’re “best effort.” The watchdog is authoritative and idempotent.

Important: the watchdog must not use or check startedRaces. It should look only at DB timestamps + status.

3) (Already done) Make price snapshot failures non-blocking

You already added the fallback to lock even if GeckoTerminal price snapshot fails. Keep that as-is.

4) sanity: CANCELLED precedence + computedStatus

You already fixed computedStatus to return CANCELLED first—great. That prevents cancelled cards from appearing as “Open”.

5) Test fast

Set short windows in env for dev:

OPEN_WINDOW_MINUTES=1
PROGRESS_WINDOW_MINUTES=1


Restart the server, clear old races (admin endpoint), load the lobby, and watch logs:

~1 min after start: ⛏️ Watchdog: force-locking… (and race_locked event)

~1 min later: ⛏️ Watchdog: force-settling… (and race_settled)

You should see the UI move through phases without refresh if you also added the SSE auto-reconnect + refetchOnWindowFocus/Reconnect.