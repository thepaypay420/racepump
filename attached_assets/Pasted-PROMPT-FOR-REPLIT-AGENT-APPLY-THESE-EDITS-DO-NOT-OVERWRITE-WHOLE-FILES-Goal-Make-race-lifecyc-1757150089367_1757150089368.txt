PROMPT FOR REPLIT AGENT — APPLY THESE EDITS (DO NOT OVERWRITE WHOLE FILES):

Goal:
Make race lifecycle robust (never stuck) and always keep exactly 3 OPEN races (1 bettable + 2 future). Keep lock snapshot baseline at 0%. Add an admin reset to cancel current races and reseed to 3.

1) server/sse.ts — small targeted changes

1A) Add time constants if missing (near top of file, below imports/sets):

// ---- Configurable durations ----
const OPEN_WINDOW_MINUTES = Number(process.env.OPEN_WINDOW_MINUTES ?? "30");
const PROGRESS_WINDOW_MINUTES = Number(process.env.PROGRESS_WINDOW_MINUTES ?? "30");
const OPEN_MS = OPEN_WINDOW_MINUTES * 60 * 1000;
const PROGRESS_MS = PROGRESS_WINDOW_MINUTES * 60 * 1000;


1B) Make timers time-aware (replace fixed 30 min waits):

In startRaceProgression(...), locate the comment // Schedule Phase 2: LOCKED transition after 30 minutes and the setTimeout(..., 30 * 60 * 1000) that follows.
Replace that entire delay with:

const nowTs = Date.now();
const msUntilLock = Math.max(0, (race.startTs + OPEN_MS) - nowTs);
setTimeout(async () => {
  // ... (existing lock code)
}, msUntilLock);


Inside that same lock block, when you schedule settlement after starting IN_PROGRESS, find:

setTimeout(async () => {
  await settleRace(race.id, inProgressRace.lockedTs as number);
}, 30 * 60 * 1000);


Replace with:

const msUntilSettle = Math.max(0, ((lockedRace.lockedTs as number) + PROGRESS_MS) - Date.now());
setTimeout(async () => {
  await settleRace(race.id, lockedRace.lockedTs as number);
}, msUntilSettle);


1C) Clear started tracking when leaving OPEN and after settle:

In the lock transition, right after:

sqliteDb.updateRace(lockedRace);
raceEvents.emit('race_locked', lockedRace);


Insert:

// No longer considered 'started' for OPEN-phase tracking
startedRaces.delete(race.id);


In settleRace(...), right after:

sqliteDb.updateRace(settledRace);


Insert:

// Finished lifecycle: ensure not tracked as started
startedRaces.delete(raceId);


1D) Add lifecycle fallbacks in the 5s loop to prevent “stuck” races:

In startCountdownUpdater(), you already have a fallback that force-locks overdue OPEN races. Immediately after that block, add both of these:

// Fallback: promote LOCKED races to IN_PROGRESS, or settle if window elapsed
try {
  const lockedRaces = sqliteDb.getRaces('LOCKED');
  for (const r of lockedRaces) {
    const lockedTs = Number(r.lockedTs || 0);
    if (!lockedTs) continue;

    // If progress window already elapsed, settle now
    if (Date.now() >= lockedTs + PROGRESS_MS) {
      console.log(`⏱️ Fallback: settling overdue LOCKED race ${r.id}`);
      try { await settleRace(r.id, lockedTs); } 
      catch (e) { console.error(`❌ Fallback settle (LOCKED) failed for ${r.id}:`, e); }
      continue;
    }

    // If we should be IN_PROGRESS by now and never transitioned, promote it
    if (!r.inProgressTs && Date.now() >= lockedTs + 2000) {
      console.log(`⏱️ Fallback: promoting race ${r.id} LOCKED → IN_PROGRESS`);
      const inProgressRace = { ...r, status: 'IN_PROGRESS' as const, inProgressTs: Date.now() };
      sqliteDb.updateRace(inProgressRace);
      raceEvents.emit('race_live', inProgressRace);
    }
  }
} catch (e) {
  console.error('❌ Fallback LOCKED→IN_PROGRESS failed:', e);
}

// Fallback: settle any IN_PROGRESS races whose window elapsed
try {
  const inProgress = sqliteDb.getRaces('IN_PROGRESS');
  for (const r of inProgress) {
    const lockedTs = Number(r.lockedTs || 0);
    if (!lockedTs) continue;
    if (Date.now() >= lockedTs + PROGRESS_MS) {
      console.log(`⏱️ Fallback: settling overdue IN_PROGRESS race ${r.id}`);
      try { await settleRace(r.id, lockedTs); } 
      catch (e) { console.error(`❌ Fallback settle (IN_PROGRESS) failed for ${r.id}:`, e); }
    }
  }
} catch (e) {
  console.error('❌ Fallback settle check failed:', e);
}


1E) Keep 3 races topped up automatically (light heartbeat):

At the end of startCountdownUpdater() (below the 10s price updater), add:

// Ensure we always top-up to 3 OPEN races
setInterval(async () => {
  try { await createNewRaceIfNeeded(); } 
  catch (e) { console.error('ensure3 failed', e); }
}, 20000);


1F) On each LOCK and SETTLE, also top up:

After you emit 'race_locked' (same place as 1C), add:

// Maintain 3 OPEN races
await createNewRaceIfNeeded();


In settleRace(...), after sqliteDb.updateRace(settledRace); startedRaces.delete(raceId);, add:

// Maintain 3 OPEN races after settlement
await createNewRaceIfNeeded();

2) createNewRaceIfNeeded() in server/sse.ts — compute future spacing from OPEN only

Edit the function so it derives spacing only from OPEN races and the betting window:

Replace the “latest future start” calculation with:

const openRaces = sqliteDb.getRaces('OPEN');
const now = Date.now();
const futureOpen = openRaces.filter(r => r.startTs > now);
const latestFutureStartTime = futureOpen.length
  ? Math.max(...futureOpen.map(r => r.startTs))
  : now;


Keep const racesNeeded = 3 - openRaces.length;

Replace const baseDelay = 30 * 60 * 1000; with:

const baseDelay = OPEN_MS;


This guarantees we always have 3 OPEN (1 current + 2 future), spaced by the betting window.

3) Add an admin reset to clear stuck races and reseed to 3

3A) In server/admin.ts (or your admin router file), add a POST route:

import express from "express";
import { clearStuckRace } from "./sse";
const router = express.Router();

router.post("/admin/reset-races", async (req, res) => {
  try {
    const { sqliteDb } = await import("./db");
    const { createNewRaceIfNeeded } = await import("./sse");

    const open = sqliteDb.getRaces("OPEN");
    const locked = sqliteDb.getRaces("LOCKED");
    const inprog = sqliteDb.getRaces("IN_PROGRESS");

    // Cancel all non-settled races and clear started tracking
    for (const r of [...open, ...locked, ...inprog]) {
      try {
        sqliteDb.updateRace({ ...r, status: "CANCELLED", cancelledTs: Date.now() });
        await clearStuckRace(r.id);
      } catch (e) {
        console.error("Failed to cancel race", r.id, e);
      }
    }

    // Reseed to 3 OPEN races (idempotent)
    await createNewRaceIfNeeded();
    await createNewRaceIfNeeded();
    await createNewRaceIfNeeded();

    const count = sqliteDb.getRaces("OPEN").length;
    res.json({ ok: true, open: count });
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

export default router;


3B) Mount this router if it isn’t already mounted.
In server/index.ts or server/routes.ts where your app is created:

import adminResetRouter from "./admin";
// ...
app.use("/api", adminResetRouter);

4) Startup wiring

In your bootstrap (likely server/index.ts), ensure both are called once:

import { initializeRaces, startCountdownUpdater } from "./sse";
await initializeRaces();
startCountdownUpdater();


If there’s any call to a placeholder reconcileStuckRaces() (from reconcile.ts with “...” content), remove or comment it out so it doesn’t break startup.

5) After deploy: reset and validate

Reset to clear the stuck race and reseed:

POST /api/admin/reset-races


Expect { ok: true, open: 3 }.

Verify in UI:

1 active OPEN race (startTs ≤ now, bettable).

2 future OPEN races (startTs > now, blurred).

Let the active one LOCK:

Baseline shows 0% at lock.

A new third future race appears (still 3 OPEN total).

Let it SETTLE or restart the server mid-race:

Fallbacks promote LOCKED → IN_PROGRESS and IN_PROGRESS → SETTLED automatically.

The 20s “ensure3” + on-LOCK/on-SETTLE top-ups keep 3 OPEN.